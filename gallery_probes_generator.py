import matplotlib.image as mpimg
import numpy as np
import os
from random import sample


class GalleryProbesGenerator:

    def __init__(self, path_to_dataset='data/dataset1/', probes_length=200):
        self.path_to_dataset = path_to_dataset
        self.path_dataset_npy = path_to_dataset + 'npy/'
        self.path_to_images = path_to_dataset + 'images/'
        self.probes_length = probes_length

    def generate_npy_files(self):
        """
        Generates all the needed datasets in "npy" folder (all datasets are numpy Arrays).
        """
        self._generate_dataset_all_elements()
        self._generate_gallery_probes()
        self._generate_merged_probes()

    def _generate_dataset_all_elements(self):
        """
        Generates 2 datasets for all pictures in "images" folder
        First dataset : array of all people's name
        Second dataset : array of all people's pictures (picture in matrix format), if a person has multiple pictures,
        pictures will be stored as an array of pictures at the person's index in the dataset.py

        One individual has the same index in both datasets

        If folder "npy" does not exist, it will be created next to "images" folder.
        Datasets "dataset_all_pictures.npy" and "dataset_all_names.npy" will be stored in this folder.py
        If they already exist, they will be deleted an re-created with the new computed datasets.
        """

        file_names = os.listdir(self.path_to_images)
        all_pictures_by_person = dict()

        for picture in file_names:
            current_name = picture.split(".")[0]

            if current_name not in all_pictures_by_person:
                all_pictures_by_person[current_name] = list()

            all_pictures_by_person[current_name].append(mpimg.imread(self.path_to_images + picture))

        for key, value in all_pictures_by_person.items():
            # converting python lists of pictures into numpy arrays of pictures
            all_pictures_by_person[key] = np.array(value)

        names_list = np.array(list(all_pictures_by_person.keys()), dtype=object)
        pictures_list = np.array(list(all_pictures_by_person.values()), dtype=object)

        # creating "npy" folder if it does not exit
        if not (os.path.exists(self.path_dataset_npy)):
            os.makedirs(self.path_dataset_npy)

        #  remove the previous generated datasets
        if os.path.exists(self.path_dataset_npy + "/dataset_all_pictures.npy"):
            os.remove(self.path_dataset_npy + "/dataset_all_pictures.npy")
        if os.path.exists(self.path_dataset_npy + "/dataset_all_names.npy"):
            os.remove(self.path_dataset_npy + "/dataset_all_names.npy")

        # saving new datasets in npy folder
        np.save(f'{self.path_dataset_npy}/dataset_all_pictures.npy', pictures_list)
        np.save(f'{self.path_dataset_npy}/dataset_all_names.npy', names_list)

    def _generate_gallery_probes(self):
        """
        It will split the datasets generated by _generate_dataset_all_elements() into 3 sub-datasets
        - gallery_name and gallery_pictures will contain information about people registered in the system
        - probe_registered_name and pictures will contain information about people registered in the system but the
        person's picture will be not in gallery_picture will contain information about people not registered in gallery
        - probe_unregistered_name and

        The npy files will be stored in "npy" folder

        Please call (after calling this method) _generate-merged_probes() if you want the full probes dataset.
        """

        if not (os.path.exists(self.path_dataset_npy + "/dataset_all_names.npy")):
            raise Exception("dataset_all_names.npy does not exist, please call _generate_dataset_all_elements() first.")

        if not (os.path.exists(self.path_dataset_npy + "/dataset_all_pictures.npy")):
            raise Exception(
                "dataset_all_pictures.npy does not exist, please call _generate_dataset_all_elements() first.")

        gallery_names = np.load(self.path_dataset_npy + "/dataset_all_names.npy", allow_pickle=True)
        gallery_pictures = np.load(self.path_dataset_npy + "/dataset_all_pictures.npy", allow_pickle=True)

        # Creating probes for unregistered people
        probe_id_unregistered = sample(range(0, gallery_names.shape[0] - 1), int(self.probes_length / 2))
        probe_unregistered_names = list()
        probe_unregistered_pictures = list()

        for probe_id in probe_id_unregistered:
            probe_unregistered_names.append(gallery_names[probe_id])
            # choosing a random picture in the array of pictures
            picture_id = sample(range(0, len(gallery_pictures[probe_id]) - 1), 1)[0]

            probe_unregistered_pictures.append(gallery_pictures[probe_id][picture_id])

        # converting python lists into numpy arrays
        probe_unregistered_names = np.array(probe_unregistered_names)
        probe_unregistered_pictures = np.array(probe_unregistered_pictures)

        # removing the unregistered people and all their pictures
        gallery_names = np.delete(gallery_names, probe_id_unregistered)
        gallery_pictures = np.delete(gallery_pictures, probe_id_unregistered)

        # Creating probes for registered people
        probe_id_registered = sample(range(0, gallery_names.shape[0] - 1), int(self.probes_length / 2))
        probe_registered_names = list()
        probe_registered_pictures = list()

        for probe_id in probe_id_registered:
            probe_registered_names.append(gallery_names[probe_id])
            # choosing a random picture in the array of pictures
            picture_id = sample(range(0, len(gallery_pictures[probe_id]) - 1), 1)[0]

            probe_registered_pictures.append(gallery_pictures[probe_id][picture_id])
            if len(gallery_pictures[probe_id]) > 1:
                gallery_pictures[probe_id] = np.delete(gallery_pictures[probe_id], [picture_id], axis=0)

        # converting python lists into numpy arrays
        probe_registered_names = np.array(probe_registered_names)
        probe_registered_pictures = np.array(probe_registered_pictures)

        # generating ground truth : elements of list with format ->(Boolean, Id_in_gallery)
        # If the boolean is False, the ID is None
        ground_truth_registered = list()
        for id_probe_in_gallery in probe_id_registered:
            ground_truth_registered.append((True, id_probe_in_gallery))

        ground_truth_unregistered = list()
        for _ in probe_id_unregistered:
            ground_truth_unregistered.append((False, None))

        # First half corresponds to the registered probes, second half corresponds to the unregistered probes
        ground_truth_merged = np.concatenate((ground_truth_registered, ground_truth_unregistered))

        #  remove the previous generated gallery datasets
        if os.path.exists(self.path_dataset_npy + "/gallery_pictures.npy"):
            os.remove(self.path_dataset_npy + "/gallery_pictures.npy")
        if os.path.exists(self.path_dataset_npy + "/gallery_names.npy"):
            os.remove(self.path_dataset_npy + "/gallery_names.npy")

        #  remove the previous generated probe registered datasets
        if os.path.exists(self.path_dataset_npy + "/probe_registered_pictures.npy"):
            os.remove(self.path_dataset_npy + "/probe_registered_pictures.npy")
        if os.path.exists(self.path_dataset_npy + "/probe_registered_names.npy"):
            os.remove(self.path_dataset_npy + "/probe_registered_names.npy")

        #  remove the previous generated probe unregistered datasets
        if os.path.exists(self.path_dataset_npy + "/probe_unregistered_pictures.npy"):
            os.remove(self.path_dataset_npy + "/probe_unregistered_pictures.npy")
        if os.path.exists(self.path_dataset_npy + "/probe_unregistered_names.npy"):
            os.remove(self.path_dataset_npy + "/probe_unregistered_names.npy")

        #  remove the previous generated ground_truth_merged
        if os.path.exists(self.path_dataset_npy + "/ground_truth_merged.npy"):
            os.remove(self.path_dataset_npy + "/ground_truth_merged.npy")

        # saving probes and gallery offline
        # gallery
        np.save(self.path_dataset_npy + '/gallery_names.npy', gallery_names)
        np.save(self.path_dataset_npy + '/gallery_pictures.npy', gallery_pictures)

        # registered probes
        np.save(self.path_dataset_npy + '/probe_registered_names.npy', probe_registered_names)
        np.save(self.path_dataset_npy + '/probe_registered_pictures.npy', probe_registered_pictures)

        # unregistered probes
        np.save(self.path_dataset_npy + '/probe_unregistered_names.npy', probe_unregistered_names)
        np.save(self.path_dataset_npy + '/probe_unregistered_pictures.npy', probe_unregistered_pictures)

        # ground truth
        np.save(self.path_dataset_npy + '/ground_truth_merged.npy', ground_truth_merged)

    def get_gallery(self):
        """
        Get numpy arrays of gallery datasets
        :return: gallery_names -> array of people's name (str)
        gallery_pictures -> array of arrays : each sub array correspond to a list of a person's pictures registered
        """

        if not (os.path.exists(self.path_dataset_npy + "/gallery_names.npy")):
            raise Exception("gallery_names.npy does not exist, please call _generate_gallery_probes() first.")

        if not (os.path.exists(self.path_dataset_npy + "/gallery_pictures.npy")):
            raise Exception("gallery_pictures.npy does not exist, please call _generate_gallery_probes() first.")

        gallery_names = np.load(self.path_dataset_npy + '/gallery_names.npy', allow_pickle=True)
        gallery_pictures = np.load(self.path_dataset_npy + '/gallery_pictures.npy', allow_pickle=True)
        return gallery_names, gallery_pictures

    def get_registered_probes(self):
        """
        Get numpy arrays of probes for registered people
        :return: probe_registered_names -> array of people's name (str)
        probe_registered_pictures -> array of pictures (pictures not in gallery)
        """

        if not (os.path.exists(self.path_dataset_npy + "/probe_registered_names.npy")):
            raise Exception("probe_registered_names.npy does not exist, please call _generate_gallery_probes() first.")

        if not (os.path.exists(self.path_dataset_npy + "/probe_registered_pictures.npy")):
            raise Exception(
                "probe_registered_pictures.npy does not exist, please call _generate_gallery_probes() first.")

        probe_registered_names = np.load(self.path_dataset_npy + '/probe_registered_names.npy', allow_pickle=True)
        probe_registered_pictures = np.load(self.path_dataset_npy + '/probe_registered_pictures.npy', allow_pickle=True)
        return probe_registered_names, probe_registered_pictures

    def get_unregistered_probes(self):
        """
        Get numpy arrays of probes for unregistered people
        :return: probe_unregistered_names -> array of people's name (str) (names not in gallery)
        probe_unregistered_pictures -> array of pictures (pictures not in gallery)
        """

        if not (os.path.exists(self.path_dataset_npy + "/probe_unregistered_names.npy")):
            raise Exception(
                "probe_unregistered_names.npy does not exist, please call _generate_gallery_probes() first.")

        if not (os.path.exists(self.path_dataset_npy + "/probe_unregistered_pictures.npy")):
            raise Exception(
                "probe_unregistered_pictures.npy does not exist, please call _generate_gallery_probes() first.")

        probe_unregistered_names = np.load(self.path_dataset_npy + '/probe_unregistered_names.npy', allow_pickle=True)
        probe_unregistered_pictures = np.load(self.path_dataset_npy + '/probe_unregistered_pictures.npy',
                                              allow_pickle=True)
        return probe_unregistered_names, probe_unregistered_pictures

    def _generate_merged_probes(self):
        """
        It will concatenate the registered and unregistered probes and save the results in "npy" folder
        First half will be registered people
        Second half will be unregistered people
        """

        probe_registered_names, probe_registered_pictures = self.get_registered_probes()
        probe_unregistered_names, probe_unregistered_pictures = self.get_unregistered_probes()

        probe_merged_names = np.concatenate((probe_registered_names, probe_unregistered_names))
        probe_merged_pictures = np.concatenate((probe_registered_pictures, probe_unregistered_pictures))

        #  remove the previous generated probes
        if os.path.exists(self.path_dataset_npy + "/probe_pictures.npy"):
            os.remove(self.path_dataset_npy + "/probe_pictures.npy")
        if os.path.exists(self.path_dataset_npy + "/probe_names.npy"):
            os.remove(self.path_dataset_npy + "/probe_names.npy")

        np.save(self.path_dataset_npy + '/probe_merged_names.npy', probe_merged_names)
        np.save(self.path_dataset_npy + '/probe_merged_pictures.npy', probe_merged_pictures)

    def get_merged_probes(self):
        """
        Get numpy arrays of all probes for unregistered and unregistered people
        :return: probe_merged_names -> array of people's name (str)
        probe_merged_pictures -> array of pictures
        """

        if not (os.path.exists(self.path_dataset_npy + "/probe_merged_names.npy")):
            raise Exception(
                "probe_merged_names.npy does not exist, please call _generate_merged_probes() first.")

        if not (os.path.exists(self.path_dataset_npy + "/probe_merged_pictures.npy")):
            raise Exception(
                "probe_merged_pictures.npy does not exist, please call _generate_merged_probes() first.")

        probe_merged_names = np.load(self.path_dataset_npy + '/probe_merged_names.npy', allow_pickle=True)
        probe_merged_pictures = np.load(self.path_dataset_npy + '/probe_merged_pictures.npy', allow_pickle=True)

        return probe_merged_names, probe_merged_pictures

    def get_ground_truth(self):
        """
        Loading ground truth : numpy array -> elements of array with format (Boolean, Id_in_gallery)
        Note : If the boolean is False, the ID is None
        First half corresponds to the registered probes, second half corresponds to the unregistered probes
        :return: numpy array as long as the probes_merged array
        """

        if not (os.path.exists(self.path_dataset_npy + "/ground_truth_merged.npy")):
            raise Exception(
                "ground_truth_merged.npy does not exist, please call _generate_gallery_probes() first.")

        ground_truth_merged = np.load(self.path_dataset_npy + '/ground_truth_merged.npy', allow_pickle=True)

        return ground_truth_merged
