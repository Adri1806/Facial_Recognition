import matplotlib.image as mpimg
import numpy as np
import os
from random import sample


class GalleryProbesGenerator:

    def __init__(self, path_to_dataset='data/dataset1/', probes_length=200):
        self.path_to_dataset = path_to_dataset
        self.path_dataset_npy = path_to_dataset + '/npy'
        self.path_to_images = path_to_dataset + '/images'
        self.probes_length = probes_length

    def generate_npy_files(self):
        """
        Generates all the needed datasets in "npy" folder (all datasets are numpy Arrays.
        """
        self._generate_dataset_all_elements()
        self._generate_gallery_probes()
        self._generate_merged_probes()

    def _generate_dataset_all_elements(self):
        """
        Generates 2 datasets for all pictures in "images" folder
        First dataset : array of all people's name
        Second dataset : array of all people's pictures (picture in matrix format), if a person has multiple pictures,
        pictures will be stored as an array of pictures at the person's index in the dataset.py

        One individual has the same index in both datasets

        If folder "npy" does not exist, it will be created next to "images" folder.
        Datasets "dataset_all_pictures.npy" and "dataset_all_names.npy" will be stored in this folder.py
        If they already exist, they will be deleted an re-created with the new computed datasets.
        """

        file_names = os.listdir(self.path_to_images)
        all_pictures_by_person = dict()

        for picture in file_names:
            current_name = picture.split(".")[0]

            if current_name not in all_pictures_by_person:
                all_pictures_by_person[current_name] = list()

            all_pictures_by_person[current_name].append(mpimg.imread(f'data/dataset1/images/{picture}'))

        for key, value in all_pictures_by_person.items():
            # converting python lists of pictures into numpy arrays of pictures
            all_pictures_by_person[key] = np.array(value)

        names_list = np.array(list(all_pictures_by_person.keys()), dtype=object)
        pictures_list = np.array(list(all_pictures_by_person.values()), dtype=object)

        # creating "npy" folder if it does not exit
        if not (os.path.exists(self.path_dataset_npy)):
            os.makedirs(self.path_dataset_npy)

        #  remove the previous generated datasets
        if os.path.exists(self.path_dataset_npy + "/dataset_all_pictures.npy"):
            os.remove(self.path_dataset_npy + "/dataset_all_pictures.npy")
        if os.path.exists(self.path_dataset_npy + "/dataset_all_names.npy"):
            os.remove(self.path_dataset_npy + "/dataset_all_names.npy")

        # saving new datasets in npy folder
        np.save(f'{self.path_dataset_npy}/dataset_all_pictures.npy', pictures_list)
        np.save(f'{self.path_dataset_npy}/dataset_all_names.npy', names_list)

    def _generate_gallery_probes(self):
        """
        It will split the datasets generated by _generate_dataset_all_elements() into 3 sub-datasets
        - gallery_name and gallery_pictures will contain information about people registered in the system
        - probe_registered_name and pictures will contain information about people registered in the system but the
        person's picture will be not in gallery_picture will contain information about people not registered in gallery
        - probe_unregistered_name and

        The npy files will be stored in "npy" folder

        Please call (after calling this method) _generate-merged_probes() if you want the full probes dataset.
        """

        if not (os.path.exists(self.path_dataset_npy + "/dataset_all_names.npy")):
            raise Exception("dataset_all_names.npy does not exist, please call _generate_dataset_all_elements() first.")

        if not (os.path.exists(self.path_dataset_npy + "/dataset_all_pictures.npy")):
            raise Exception(
                "dataset_all_pictures.npy does not exist, please call _generate_dataset_all_elements() first.")

        gallery_names = np.load(self.path_dataset_npy + "/dataset_all_names.npy", allow_pickle=True)
        gallery_pictures = np.load(self.path_dataset_npy + "/dataset_all_pictures.npy", allow_pickle=True)

        # copy for tests after splitting data
        dataset_all_names = np.load("data/dataset1/npy/dataset_all_names.npy", allow_pickle=True)
        dataset_all_pictures = np.load("data/dataset1/npy/dataset_all_pictures.npy", allow_pickle=True)

        probe_id_global = sample(range(0, gallery_names.shape[0] - 1), self.probes_length)
        probe_id_registered = probe_id_global[:int(self.probes_length / 2)]
        probe_id_unregistered = probe_id_global[int(self.probes_length / 2):]

        # Creating probes for registered people
        probe_registered_names = list()
        probe_registered_pictures = list()
        # next list will be useful later to check if probe_register_pictures correctly created
        pictures_to_delete_from_gallery = list()

        for probe_id in probe_id_registered:
            probe_registered_names.append(gallery_names[probe_id])
            # choosing a random picture in the array of pictures
            picture_id = sample(range(0, len(gallery_pictures[probe_id]) - 1), 1)[0]
            pictures_to_delete_from_gallery.append((probe_id, picture_id))

            probe_registered_pictures.append(gallery_pictures[probe_id][picture_id])
            gallery_pictures[probe_id] = np.delete(gallery_pictures[probe_id], [picture_id], axis=0)

        # converting python lists into numpy arrays
        probe_registered_names = np.array(probe_registered_names)
        probe_registered_pictures = np.array(probe_registered_pictures)

        # test to see if probe_register names and pictures well created
        for i, (current_id, picture_id) in enumerate(pictures_to_delete_from_gallery):

            # check if one picture is correctly deleted for the current person in the gallery
            if len(gallery_pictures[current_id]) + 1 != len(dataset_all_pictures[current_id]):
                print(f"{gallery_names[current_id]} -> wrong pictures number after putting in probe registered")

            # check if the right picture is placed in probe_registered_pictures
            if not (np.array_equal(probe_registered_pictures[i], dataset_all_pictures[current_id][picture_id])):
                print(f'{probe_registered_names[i]} -> wrong picture copied')

            # check if the picture placed in probe_registered_pictures is the one deleted
            if np.array_equal(gallery_pictures[current_id][picture_id], dataset_all_pictures[current_id][picture_id]):
                print(f"{probe_registered_names[i]} -> wrong picture deleted in gallery")

        # Creating probes for unregistered people
        probe_unregistered_names = list()
        probe_unregistered_pictures = list()
        # next list will be useful later to check if probe_register_pictures correctly created
        people_to_delete_from_gallery = list()

        for probe_id in probe_id_unregistered:
            probe_unregistered_names.append(gallery_names[probe_id])
            # choosing a random picture in the array of pictures
            picture_id = sample(range(0, len(gallery_pictures[probe_id]) - 1), 1)[0]
            people_to_delete_from_gallery.append((probe_id, gallery_names[probe_id]))

            probe_unregistered_pictures.append(gallery_pictures[probe_id][picture_id])

        # converting python lists into numpy arrays
        probe_unregistered_names = np.array(probe_unregistered_names)
        probe_unregistered_pictures = np.array(probe_unregistered_pictures)

        # removing the unregistered elements and their pictures
        gallery_names = np.delete(gallery_names, probe_id_unregistered)
        gallery_pictures = np.delete(gallery_pictures, probe_id_unregistered)

        # test to see if probe_unregister names and pictures well created
        for i, (current_id, current_name) in enumerate(people_to_delete_from_gallery):

            # check if all the names are removed
            if current_name in gallery_names:
                print(f'{current_name} not deleted from gallery')
            # check if all probes correctly added
            if current_name not in probe_unregistered_names:
                print(f'{current_name} not in probes unregister')

            if gallery_pictures.shape[0] != dataset_all_pictures.shape[0] - self.probes_length / 2:
                print(f'Not the correct number of element in pictures gallery')

        #  remove the previous generated gallery datasets
        if os.path.exists(self.path_dataset_npy + "/gallery_pictures.npy"):
            os.remove(self.path_dataset_npy + "/gallery_pictures.npy")
        if os.path.exists(self.path_dataset_npy + "/gallery_names.npy"):
            os.remove(self.path_dataset_npy + "/gallery_names.npy")

        #  remove the previous generated probe registered datasets
        if os.path.exists(self.path_dataset_npy + "/probe_registered_pictures.npy"):
            os.remove(self.path_dataset_npy + "/probe_registered_pictures.npy")
        if os.path.exists(self.path_dataset_npy + "/probe_registered_names.npy"):
            os.remove(self.path_dataset_npy + "/probe_registered_names.npy")

        #  remove the previous generated probe unregistered datasets
        if os.path.exists(self.path_dataset_npy + "/probe_unregistered_pictures.npy"):
            os.remove(self.path_dataset_npy + "/probe_unregistered_pictures.npy")
        if os.path.exists(self.path_dataset_npy + "/probe_unregistered_names.npy"):
            os.remove(self.path_dataset_npy + "/probe_unregistered_names.npy")

        # saving probes and gallery offline
        # gallery
        np.save(self.path_dataset_npy + '/gallery_names.npy', gallery_names)
        np.save(self.path_dataset_npy + '/gallery_pictures.npy', gallery_pictures)

        # registered probes
        np.save(self.path_dataset_npy + '/probe_registered_names.npy', probe_registered_names)
        np.save(self.path_dataset_npy + '/probe_registered_pictures.npy', probe_registered_pictures)

        # unregistered probes
        np.save(self.path_dataset_npy + '/probe_unregistered_names.npy', probe_unregistered_names)
        np.save(self.path_dataset_npy + '/probe_unregistered_pictures.npy', probe_unregistered_pictures)

    def get_gallery(self):
        """
        Get numpy arrays of gallery datasets
        :return: gallery_names -> array of people's name (str)
        gallery_pictures -> array of arrays : each sub array correspond to a list of a person's pictures registered
        """

        if not (os.path.exists(self.path_dataset_npy + "/gallery_names.npy")):
            raise Exception("gallery_names.npy does not exist, please call _generate_gallery_probes() first.")

        if not (os.path.exists(self.path_dataset_npy + "/gallery_pictures.npy")):
            raise Exception("gallery_pictures.npy does not exist, please call _generate_gallery_probes() first.")

        gallery_names = np.load(self.path_dataset_npy + '/gallery_names.npy', allow_pickle=True)
        gallery_pictures = np.load(self.path_dataset_npy + '/gallery_pictures.npy', allow_pickle=True)
        return gallery_names, gallery_pictures

    def get_registered_probes(self):
        """
        Get numpy arrays of probes for registered people
        :return: probe_registered_names -> array of people's name (str)
        probe_registered_pictures -> array of pictures (pictures not in gallery)
        """

        if not (os.path.exists(self.path_dataset_npy + "/probe_registered_names.npy")):
            raise Exception("probe_registered_names.npy does not exist, please call _generate_gallery_probes() first.")

        if not (os.path.exists(self.path_dataset_npy + "/probe_registered_pictures.npy")):
            raise Exception(
                "probe_registered_pictures.npy does not exist, please call _generate_gallery_probes() first.")

        probe_registered_names = np.load(self.path_dataset_npy + '/probe_registered_names.npy', allow_pickle=True)
        probe_registered_pictures = np.load(self.path_dataset_npy + '/probe_registered_pictures.npy', allow_pickle=True)
        return probe_registered_names, probe_registered_pictures

    def get_unregistered_probes(self):
        """
        Get numpy arrays of probes for unregistered people
        :return: probe_unregistered_names -> array of people's name (str) (names not in gallery)
        probe_unregistered_pictures -> array of pictures (pictures not in gallery)
        """

        if not (os.path.exists(self.path_dataset_npy + "/probe_unregistered_names.npy")):
            raise Exception(
                "probe_unregistered_names.npy does not exist, please call _generate_gallery_probes() first.")

        if not (os.path.exists(self.path_dataset_npy + "/probe_unregistered_pictures.npy")):
            raise Exception(
                "probe_unregistered_pictures.npy does not exist, please call _generate_gallery_probes() first.")

        probe_unregistered_names = np.load(self.path_dataset_npy + '/probe_unregistered_names.npy', allow_pickle=True)
        probe_unregistered_pictures = np.load(self.path_dataset_npy + '/probe_unregistered_pictures.npy',
                                              allow_pickle=True)
        return probe_unregistered_names, probe_unregistered_pictures

    def _generate_merged_probes(self):
        """
        It will concatenate the registered and unregistered probes and save the results in "npy" folder
        First half will be registered people
        Second half will be unregistered people
        """

        probe_registered_names, probe_registered_pictures = self.get_registered_probes()
        probe_unregistered_names, probe_unregistered_pictures = self.get_unregistered_probes()

        probe_merged_names = np.concatenate((probe_registered_names, probe_unregistered_names))
        probe_merged_pictures = np.concatenate((probe_registered_pictures, probe_unregistered_pictures))

        #  remove the previous generated probes
        if os.path.exists(self.path_dataset_npy + "/probe_pictures.npy"):
            os.remove(self.path_dataset_npy + "/probe_pictures.npy")
        if os.path.exists(self.path_dataset_npy + "/probe_names.npy"):
            os.remove(self.path_dataset_npy + "/probe_names.npy")

        np.save(self.path_dataset_npy + '/probe_merged_names.npy', probe_merged_names)
        np.save(self.path_dataset_npy + '/probe_merged_pictures.npy', probe_merged_pictures)

    def get_merged_probes(self):
        """
        Get numpy arrays of all probes for unregistered and unregistered people
        :return: probe_merged_names -> array of people's name (str)
        probe_merged_pictures -> array of pictures (pictures not in gallery)
        """

        if not (os.path.exists(self.path_dataset_npy + "/probe_merged_names.npy")):
            raise Exception(
                "probe_merged_names.npy does not exist, please call _generate_merged_probes() first.")

        if not (os.path.exists(self.path_dataset_npy + "/probe_merged_pictures.npy")):
            raise Exception(
                "probe_merged_pictures.npy does not exist, please call _generate_merged_probes() first.")

        probe_merged_names = np.load(self.path_dataset_npy + '/probe_merged_names.npy', allow_pickle=True)
        probe_merged_pictures = np.load(self.path_dataset_npy + '/probe_merged_pictures.npy', allow_pickle=True)

        return probe_merged_names, probe_merged_pictures

    def get_ground_truth(self):
        """
        Creates an array containing the truth of the registration (person in the gallery or not) of each probe
        :return: Numpy array of Boolean
        """
        gt = list()
        for i in range(self.probes_length):
            gt.append(True if i < self.probes_length else False)
        return np.array(gt)
